#!/bin/bash -eu

set -o pipefail

realpath() {
    if [ "$(uname -s)" = "Darwin" ]; then
        perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"
    else
        readlink -f "$1"
    fi
}

project="$(realpath $1)"

###################################################################
# Helpers
###################################################################

error() {
    echo $1
    exit 2
}

dir-empty() {
    local dir=$1
    [ -z "$(ls -A $dir)" ]
}

url-filename() {
    local url=$1
    local filename
    filename=${url##*/}
    filename=${filename%%.*}
    echo $filename
}

pushd-quiet() {
    pushd $1 > /dev/null
}

popd-quiet() {
    popd > /dev/null
}

###################################################################
# Source dir
###################################################################

srcdir-init() {
    srcdir="$(realpath ${ALT_SRCDIR:-$project/src})"
    if [ ! -z "${CLEAN:-}" ]; then
        echo "Cleaning sources"
        rm -rf "$srcdir"
    fi
    mkdir -p "$srcdir"
}

###################################################################
# Sources
###################################################################

maybe-sources() {
    if [ -z "${SKIP_SOURCES:-}" ]; then
        sources-download
        sources-check
        sources-extract
    else
        echo "Skipping sources"
    fi
}

###################################################################
# Sources download
###################################################################

sources-download() {
    for src in $package_source; do
        source-download "$src"
    done
}

source-download() {
    local src=$1
    if [ -f "$src" ]; then
        true
    elif [ "${src:0:4}" = "git+" ]; then
        git-download "${src:4}"
    else
        error "$src does not exist or is not a supported source type"
    fi
}

git-download() {
    local url=$1
    local repo_name=$(url-filename $url)
    local repo_dest=$project/$repo_name
    if [ ! -e "$repo_dest" ] || dir-empty "$repo_dest"; then
        echo "Cloning $url"
        git clone --mirror "$url" "$repo_dest"
    else
        echo "Updating $repo_name"
        pushd-quiet "$repo_dest"
        git fetch --all -p
        popd-quiet
    fi
}

###################################################################
# Sources check
###################################################################

sources-check() {
    # TODO
    #
    # This is a place holder for an important feature - enough to stub
    # out. The user should be able to specify checksums to apply to
    # source artifacts.
    true
}

###################################################################
# Sources extract
###################################################################

sources-extract() {
    for src in $package_source; do
        source-extract "$src"
    done
}

source-extract() {
    local src=$1
    if [ -f "$src" ]; then
        source-file-copy "$src"
    elif [ "${src:0:4}" = "git+" ]; then
        git-extract "${src:4}"
    else
        error "$src is not a supported source type"
    fi
}

source-file-copy() {
    local file=$1
    echo "Copying source $file"
    cp "$file" "$srcdir/"
}

git-extract() {
    local url=$1
    local repo_name=$(url-filename $url)
    local repo_src=$project/$repo_name
    local repo_dest=$srcdir/$repo_name
    echo "Creating working copy of $repo_name"
    if [ ! -e "$repo_dest" ] || dir-empty "$repo_dest"; then
        echo "Cloning $url"
        git clone "$repo_src" "$repo_dest"
    else
        echo "Updating $repo_name"
        pushd-quiet "$repo_dest"
        git fetch
        # TODO support for branch=xxx, tag=xxx, commit=xxx
        git checkout
        popd-quiet
    fi
}

###################################################################
# Package
###################################################################

pkgdir-init() {
    pkgdir="$project/pkg"
    if [ -e "$pkgdir" ]; then
        echo "Removing package directory $pkgdir"
        rm -rf "$pkgdir"
    fi
    mkdir -p "$pkgdir"
}

maybe-package() {
    if [ -z "${SKIP_PACKAGE:-}" ]; then
        build-functions
        package-finalize
    else
        echo "Skipping package"
    fi
}

build-functions() {
    build-functions-init
    build-function-call prepare
    build-function-call build
    build-function-call package
}

build-functions-init() {
    source "$project/build"
}

build-function-call() {
    local name=$1
    if type -t $name > /dev/null; then
        echo "Running $name"
        pushd-quiet "$srcdir"
        eval $name
        popd-quiet
    fi
}

package-finalize() {
    cp "$project/Guild" "$pkgdir/Guild"
}

###################################################################
# Archive
###################################################################

maybe-archive() {
    if [ -z "${SKIP_PACKAGE:-}" ] && [ -z "${SKIP_ARCHIVE:-}" ]; then
        package-archive
    else
        echo "Skipping archive"
    fi
}

package-archive() {
    local pkg="$package_name-$package_version.pkg.tar.xz"
    echo "Creating $pkg"
    tar -C "$pkgdir" -cjf "$pkg" .
}

###################################################################
# Main
###################################################################

srcdir-init
maybe-sources
pkgdir-init
maybe-package
maybe-archive
